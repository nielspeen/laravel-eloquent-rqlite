<?php

namespace Wanwire\LaravelEloquentRQLite\Driver;

use CurlHandle;
use Doctrine\DBAL\Driver\Result;

use Doctrine\DBAL\ParameterType;
use Exception;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;
use PDO;
use PDOException;
use PDOStatement;

class RQLiteStatement extends PDOStatement implements \Doctrine\DBAL\Driver\Statement
{
    private string $sql;
    private CurlHandle $connection;
    private string $baseUrl;
    public int $lastInsertId;

    private array $parameterizedMap = [];
    private int $fetchMode = PDO::FETCH_ASSOC;
    private ?string $fetchClassName = null;
    private array $fetchParams = [];

    public function __construct(string $sql, $connection, $baseUrl)
    {
        $this->sql = $sql;
        $this->connection = $connection;
        $this->baseUrl = $baseUrl;
    }

    public function bindValue($param, $value, $type = ParameterType::STRING): bool
    {
        $this->parameterizedMap[] = $value;

        return true;
    }

    public function bindParam(
        $param,
        mixed &$variable,
        $type = PDO::PARAM_STR,
        $length = 0,
        mixed $driverOptions = null
    ): bool {
        return parent::bindParam(
            $param,
            $variable,
            $type,
            $length,
            $driverOptions
        ); // TODO: Change the autogenerated stub
    }

    #[\ReturnTypeWillChange]
    public function execute($params = null): Result
    {
        return new RQLiteResult($this->requestRQLiteByHttp());
    }

    public function fetchAll(int $mode = PDO::FETCH_DEFAULT, mixed ...$args): array
    {
        $fetchMode = ($mode === PDO::FETCH_DEFAULT) ? $this->fetchMode : $mode;
        $results = $this->requestRQLiteByHttp();

        if (empty($results)) {
            return [];
        }

        $results = $results[0];
        $tmp = [];

        if (isset($results['values'])) {
            foreach ($results['values'] as $key => $item) {
                foreach ($results['columns'] as $k => $i) {
                    if ($fetchMode === PDO::FETCH_OBJ) {
                        $tmp[$key][$i] = $item[$k];
                    } else {
                        $tmp[$key][$i] = $item[$k];
                    }
                }
                if ($fetchMode === PDO::FETCH_OBJ) {
                    $tmp[$key] = (object)$tmp[$key];
                } elseif ($fetchMode === PDO::FETCH_CLASS) {
                    $tmp[$key] = $this->instantiateFetchClass($tmp[$key]);
                }
            }
        }

        return $tmp;
    }

    private function instantiateFetchClass(array $row)
    {
        $className = $this->fetchClassName ?? 'stdClass';
        $params = $this->fetchParams;

        if ($params) {
            $reflectionClass = new \ReflectionClass($className);
            return $reflectionClass->newInstanceArgs($params);
        } else {
            return new $className($row);
        }
    }

    private function makeRequestData(string $sql, array $parameterizedMap): array
    {
        return [[$sql, ...$parameterizedMap]];
    }

    private function requestRQLiteByHttp()
    {
        $consistencyLevel = DB::connection('rqlite')->getConsistencyLevel();

        if (Str::startsWith(Str::upper($this->sql), ['SELECT', 'PRAGMA'])) {
            $uri = '/db/query?level=' . $consistencyLevel . '&timings=true';
        } else {
            $uri = '/db/execute';
        }

        $jsonOptionData = json_encode($this->makeRequestData($this->sql, $this->parameterizedMap));

        curl_setopt($this->connection, CURLOPT_POSTFIELDS, $jsonOptionData);
        curl_setopt($this->connection, CURLOPT_URL, $this->baseUrl . $uri);

        $response = curl_exec($this->connection);
        $httpCode = curl_getinfo($this->connection, CURLINFO_HTTP_CODE);

        if ($response === false || $httpCode !== 200) {
            $error = curl_error($this->connection);
            curl_close($this->connection);
            throw new Exception("cURL request failed with error: $error and HTTP code: $httpCode");
        }

        $result = json_decode($response, true);

        if (isset($result['results'])) {
            collect($result['results'])->map(function ($item) {
                if (isset($item['error'])) {
                    throw new PDOException($item['error']);
                }
            });
        }

        if (isset($result['results'][0]['last_insert_id'])) {
            $this->lastInsertId = $result['results'][0]['last_insert_id'];
        }

        return $result['results'];
    }

    protected function isReadOnlyDatabaseError(PDOException $e): bool
    {
        return str_contains($e->getMessage(), 'attempt to write a readonly database');
    }

    public function setFetchMode($mode, $className = null, ...$params): void
    {
        $this->fetchMode = $mode;
        $this->fetchClassName = $className;
        $this->fetchParams = $params;
    }


    // TODO: hack to fix delete
    public function rowCount(): int
    {
        return 0;
    }

}
